	#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Author Federico Baraglia
Date 27.2.2019

Important functions for the Resolution of overdamped Langevin Equation of Motion

"""

import numpy as np
import os
import numpy.linalg as LA
#import matplotlib.pyplot as plt
import torch
import time
import math


os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'

a = 3.16 # Lattice constant in Å (for W)

# Pytorch parameters
dtype = torch.double
device = torch.device('cpu')

# Data for accelerating
ind_to_tensor = np.array([0 for i in range(81)], dtype = list)
ind = 0
for i in range (3):
    for j in range (3):
        for k in range (3):
            for l in range (3):
                ind_to_tensor[ind] = [i,j,k,l]
                ind += 1

# Secondary data for accelerating
# these lists contain the 81 (x,y or z [0,1 or 2])
# associated with the 81 possible configurations (3**4)
# They are in such an order that when we use reshape (3,3,3,3)
# the 4th order tensor is the same as if the i,j,k,l coordinate was generated by
# the function greenDD(r,i,j,k,l,nu,mu)
ii = np.array([ind_to_tensor[int(x)][0] for x in range(81)])
jj = np.array([ind_to_tensor[int(x)][1] for x in range(81)])
kk = np.array([ind_to_tensor[int(x)][2] for x in range(81)])
ll = np.array([ind_to_tensor[int(x)][3] for x in range(81)])

ii_jj = np.array(ii==jj, dtype = 'd')
ii_kk = np.array(ii==kk, dtype = 'd')
ii_ll = np.array(ii==ll, dtype = 'd')
kk_jj = np.array(jj==kk, dtype = 'd')
jj_ll = np.array(jj==ll, dtype = 'd')
kk_ll = np.array(kk==ll, dtype = 'd')

# Kronecker delta function
def kronD(i,j):
    """
    This function returns 1 if i=j and 0 if i!=j
    Obsolete...
    """
    if (i == j):
        return 1
    else:
        return 0


# Dirac Delta function
def diracD(r):
    """
    Obsolete as well
    """
    # Idem as Kronecker but with 3D continuum
    if (r.equal(torch.tensor([0,0,0], dtype = dtype, device = device))):
        return 1
    else:
        return 0

# Double derivative, Green's elastic function
# The JIT module is not as effective as I thought it would be
# @torch.jit.script
def greenDD(r, i, j, k, l, nu, mu):
    """
    This function compute G_{ik,jl} for two dislocation (Gij is the Elastic green function)
    loops separated by r[3]
    INPUT : r[3] position, i,j,k,l in {0,1,2} and Lamé coefficients (nu, mu)
    OUTPUT : Gik,jl
    """

    r_norm = torch.norm(r) # r_norm is the Euclidean norm of vector r
    eta = r.div(r_norm) # eta is the unit vector pointing in the same direction of r

    prefactor = 1.0/(16.0*math.pi*mu*(1 - nu)*r_norm**3) # prefactor Eq (9)

    # We divide, for readability, the next factor in several terms
    # For more details, see Eq (9) in PRM 2, 033602
    term1 = torch.tensor([0.0])
    term2 = torch.tensor([0.0])

    if (i == k):
        term1 = (3.0 - 4.0*nu)*(3.0*eta[l]*eta[j] - int(l==j))

    if (i==j):
        term2 += eta[k]*eta[l]
    if (i==l):
        term2 += eta[j]*eta[k]
    if (j==l):
        term2 += eta[i]*eta[k]
    if (k==j):
        term2 +=eta[i]*eta[l]
    if (k==l):
        term2 +=eta[i]*eta[j]


    term2 *= -3.0

    term2 += 15.0*eta[i]*eta[j]*eta[k]*eta[l]

    term3 = (i==l)*(k==j) + (i==j)*(k==l)

    Gik_jl = prefactor*(term1 + term2 + term3)

    return Gik_jl


# Double derivative, Green's elastic function
# @torch.jit.script
def greenDD_mod(r, nu, mu):
    """
    This function compute G_ijkl the 4th order tensor which coordinates are
    G_ik,jl(r,nu,mu) for two dislocation (Gij is the Elastic green function)
    loops separated by r[3]
    INPUT : r[3] position and Lamé coefficients (nu, mu)
    OUTPUT : Gijkl (4th order tensor)
    """
    #
    # t0 = time.time()
    r_norm = np.sqrt(sum([x**2 for x in np.array(r)])) # r_norm is the Euclidean norm of vector r
    eta = [x/r_norm for x in np.array(r)] # eta is the unit vector pointing in the same direction of r
    # t1 = time.time()
    eta_i = np.array([eta[x] for x in ii], dtype = 'd')
    eta_j = np.array([eta[x] for x in jj], dtype = 'd')
    eta_k = np.array([eta[x] for x in kk], dtype = 'd')
    eta_l = np.array([eta[x] for x in ll], dtype = 'd')
    # t2 = time.time()
    prefactor = 1.0/(16.0*math.pi*mu*(1 - nu)*r_norm**3) # prefactor Eq (9)

    # We divide, for readability, the next factor in several terms
    # For more details, see Eq (9) in PRM 2, 033602
    # t3 = time.time()
    term1 = (3.0 - 4.0*nu)*(ii_kk)*(3.0*eta_l*eta_j - jj_ll)
    # t4 = time.time()
    term2 = 15.0*eta_i*eta_j*eta_k*eta_l -\
    3.0*(eta_k*(ii_jj*eta_l + ii_ll*eta_j + jj_ll*eta_i) + \
       + eta_i*(kk_jj*eta_l + kk_ll*eta_j))

    # t5 = time.time()
    term3 = ii_ll*kk_jj + ii_jj*kk_ll
    # t6 = time.time()
    Gik_jl = prefactor*(term1 + term2 + term3)
    # print(t1 - t0, t2 - t1, t3 - t2, t4 - t3,'\n', t5 - t4, t6 - t5, time.time() - t6)
    return Gik_jl


def greenDD_study():
    """
    This function helps us understand what is the behaviour of Green's elastic function for tungsten
    Input : -
    Output : figure
    """
    bound = 30
    nu = 0.278
    mu = 1.006

    # Direction that separates the two points we are studying
    direc = torch.tensor([1, 1, 1], dtype = dtype)

    # Bounds of the study
    w = np.linspace(-bound, bound, 10*bound)

    # Initial vector separating the studied points
    Rab_init = np.array([10,10,0])
    # Initialisation of the figure
    plt.figure(figsize=(22,22))

    # For each component of Green elastic function
    for i in range(3):
        for j in range(3):
            for k in range(3):
                for l in range(3):
                    Gik_jl_study = []
                    for wi in range(10*bound):
                        Gik_jl_study += [greenDD(Rab_init + w[wi]*direc,i,j,k,l,nu,mu)]

        #G_study[wi] = Gik_jl_study

                    if (i == 0 and k == 0):
                        plt.subplot(331)
                    if (i == 0 and k == 1):
                        plt.subplot(332)
                    if (i == 0 and k == 2):
                        plt.subplot(333)
                    if (i == 1 and k == 0):
                        plt.subplot(334)
                    if (i == 1 and k == 1):
                        plt.subplot(335)
                    if (i == 1 and k == 2):
                        plt.subplot(336)
                    if (i == 2 and k == 0):
                        plt.subplot(337)
                    if (i == 2 and k == 1):
                        plt.subplot(338)
                    if (i == 2 and k == 2):
                        plt.subplot(339)

                    plt.plot(w, Gik_jl_study, label = \
                                 '$G_{'+str(i+1)+str(k+1)+','+str(j+1)+str(l+1)+'}$')


                    plt.xlabel("Distance between the two defects in the $111$ direction ($\AA$).")
                    plt.ylabel("$G$, Green's elastic function ($eV^{-1}$)")
                    plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
                    plt.grid()
                    plt.legend()

    plt.title("Green's elastic function ")
    plt.savefig("green_study", format = 'pdf')

    return 0

# Elastic compliance tensor
def define_C(nu,mu):
    """
    This function returns the elastic compliance tensor
    Input : physical constants
    Output : C
    """
    # Initialise the tensor
    compliance = torch.zeros((3,3,3,3), dtype = dtype)

    for i in range (3):
        for j in range(3):
            for k in range(3):
                for l in range(3):
                    compliance[i,j,k,l] = mu * (2 * nu / (1.0 - 2.0 * nu) * int(i==j)*int(k==l) \
                                            + (int(i==k)*int(j==l) + int(i==l)*int(k==j)))

    return compliance


def define_S(nu, mu):
    """
    This function return the elastic compliance tensor S
    Input : nu, mu
    Ouput : 4th order tensor S
    """
    S = torch.zeros((3,3,3,3), dtype = dtype)
    C = define_C(nu,mu)
    E = 2*mu*(1 + nu)

    for i in range(3):
        S[i,i,i,i] = 1/E
        for j in range(3):
            S[i,i,j,j] = -nu/E
            S[i,j,i,j] += 0.5 * (1 + nu)/E
            S[i,j,j,i] += 0.5 * (1 + nu)/E

    return S

def sigma(P, r, nu, mu, Compliance):
    """
    This function computes the ab stress component in a position r (relative to the dislocation loop)
    which dipole tensor is P
    Input : ab components [0 1 2], P dipole tensor np.array((3 3)),
    r-R (position of computation - position of loop R), physical constants nu/mu
    Output sigma_ab(r-R)
    """

    # Define the green tensor
    # t0 = time.time()
    G_ijkl = torch.tensor(greenDD_mod(r,nu,mu).reshape(3,3,3,3), dtype = dtype)
    # t1 = time.time()
    # sigma_ab = C_abij * eps_ij
    # And eps_ij = - G_ijkl * Pkl
    # (Where G_ijkl is the 4th order tensor which components are G_ik,jl(r,nu,mu))
    sigma_ab = - torch.tensordot(Compliance, torch.tensordot(G_ijkl, P, 2), 2)
    # print(t1 - t0, time.time() - t1)
    return sigma_ab

# xsi is a normal distributed random variable N(0, delta_t)
def xsi():
    """
    This function returns a random number which describe the stochastic part of the SDE
    Input : time step dt
    Output : Random number normaly distributed
    """
    return np.random.normal(loc = 0.0, scale = 1.0)

def degenerate_loop(dipole_tensor, burger, sign):
    """
    This function changes the dipole tensor and burger vector if the direction is degenerate
    Input : dipole tensor P np.array(3*3), sign np.array(1*3) with ±1, Burger vector np.array(1*3)
    Output : dipole tensor change coordinates P np.array(3*3), Burger vector change coordinates B np.array(1*3)
    """

    for i in range(3):
        for j in range(3):
            dipole_tensor[i,j] = dipole_tensor[i,j]*sign[i]*sign[j]
    for i in range(3):
        burger[i] = burger[i]*sign[i]

    return dipole_tensor, burger

def sia_or_vac(radius, kind):
    """
    This function changes the dipole tensor according to the kind of dislocation loop it is
    interstitial or vacancy...
    Input : Old burger vector and kind (1 = sia, -1 = vac)
    Output : New burger vector
    """
    radius = kind*radius
    return radius


# If the loop is not normal to its burger vector than this function must
# be changed /!\/!\ The vector A is not A*b...
def dipole_coord_analytical(burger, radius, nu, mu, a):
    '''
    This function computes the analytical dipole tensor coordinates
    according to PRM 2, 033602
    '''
    # Dislocation loop
    if (radius > 1.5559 or radius <= -5):
        A = np.pi * radius**2
        P = torch.zeros((3,3), dtype = dtype, device = device)
        A = A*burger
        for i in range(3):
            for j in range(3):
                P[i,j] = mu*(burger[i]*A[j] + burger[j]*A[i] + 2*nu/(1 - 2*nu)*torch.dot(burger,A)*int(i==j))
        return P
    else :
        # VAC defect see universality of point defect structure in bcc metals
        if (radius >= -1.556 and radius <= -1.555):
            Pii = - 9.984
            P = torch.tensor([[Pii, 0, 0], [0, Pii, 0], [0, 0, Pii]], dtype = dtype, device = device)
            return P
        # SIA defect see symmetry broken sia defects in cr, mo and W
        if (radius <= 1.556 and radius >= 1.555):
            Paa = 50.921
            Pxx = 57.883
            Pab = 9.136
            Pax = 11.925

            P = torch.tensor([[Paa, Pab, Pab], [Pab, Paa, Pab], [Pab, Pab, Paa]], dtype = dtype, device = device)
            xsi = np.random.randint(0,3)

            P[xsi, xsi] = Pxx
            P[(xsi + 1)%3, (xsi + 2)%3] = Pax
            P[(xsi + 2)%3, (xsi + 1)%3] = Pax

            return P
        # VOID : see relaxation volumes of microscopic and mesoscopic irradiation-induced
        #           defects in W
        else :
            s = 0.360
            N = num_atoms(radius, a)
            term1 = (243.0*math.pi/8.0)**(1.0/3.0)
            term2 = (1 - nu)/(1 + nu)

            Ome_rel = -term1 * term2 * s*a**2/mu * np.abs(N)**(2.0/3.0)
            Ome = torch.eye(3, dtype = dtype).mul(Ome_rel/3.0)

            C = define_C(nu, mu)
            P = torch.tensordot(C, Ome, 2)

            return P

def num_atoms(r, b, a):
    """
    This function computes the number of atoms containend in a loop
    of radius r (always for 111 loops since for 100 we don't need it)
    Input : radius r in Å, a lattice constant in Å and burger vector b
    Output : Number of atoms N
    """
    if -5 < r.item() < 1.5559:
        # print('SIA, VAC, void')
        return 8.0/3.0*math.pi*(np.abs(r.item())/a)**3
    else :
        # print('Loop')
        return int(2.0/a**3*math.pi*r.item()**2*torch.norm(b))

# r = torch.tensor([100], dtype = dtype)
# b = torch.tensor([0.5,0.5,0.5], dtype = dtype)
# a = 3.16
# print(num_atoms(r,b,a))

def size_from_num_atoms(N, b, a):
    """
    This is the inverse of the function above
    it returns the radius when the input is the number of atoms involved
    """
    r = np.sqrt(N*a**3/(2*math.pi*torch.norm(b)))
    return r


def collision_100SIA_to_SIA(node1, node2, new_node):
    """
    This functions returns True if node1 and node2 collide according to the following rules:
     - node1/2 is the biggest loop and a 100 SIA and the resulting loop is a 111 SIA
    Input : The two nodes
    OUTPUT : True if it is the case, false if not
    """
    if (node1.val.size > node2.val.size):
        if (node1.val.kind == 'SIA_s' and new_node.val.kind == 'SIA_g'):
            return True
        else :
            return False
    else :
        return False


def formation_volume_elem(defect, elastic_compliance, lattice_constant):
    """
    This function returns the formation energy of one loop
    Input : defect loop object
    Output : Formation energy of the defect OmeF_elem
    """
    # Compute the relaxation volume tensor for the defect
    Ome_rel = torch.tensordot(elastic_compliance, torch.abs(defect.dtensor), 2)
    # The trace of it :
    OmeR = Ome_rel.trace()
    OmeR = torch.norm(defect.burger)*math.pi*defect.size**2
    N = num_atoms(defect.size, defect.burger, lattice_constant)
    # print(N)
    # Atomic volume
    Ome_0 = lattice_constant**3/2.0

    OmeF_elem = OmeR - N * Ome_0
    return OmeF_elem

def formation_volume(Zll, nu, mu, a):
    """
    This function returns the formation volume of a given configuration
    Input : linked list system Zll, (nu, mu) Lame coefficients
    Output : Formation energy OmeF
    """
    # Initialise the formation volume to 0
    OmeF = torch.tensor([0.0], dtype = dtype)

    # Initialise the elastic compliance tensor S ( eps_ij = S_ijkl * sig_kl)
    elastic_compliance = define_S(nu,mu)

    # Number of cell per side :
    dim_Zllp = Zll.shape[0]
    dim_Zllz = Zll.shape[2]
    for i in range(dim_Zllp):
        for j in range(dim_Zllp):
            for k in range(dim_Zllz):
                curr_list = Zll[i,j,k]
                curr_node = curr_list.head

                while(curr_node != None):
                    OmeF += formation_volume_elem(curr_node.val, elastic_compliance, a)
                    curr_node = curr_node.next
    return OmeF.item()

def curr_node_id():
    """
    This function returns the max of nodes id
    Input : -
    Output : Max node id
    """

    dir = os.getcwd()
    os.chdir(dir + '/Cast3m/simu/')

    files = os.listdir(os.getcwd())
    node_ids = []

    for file in files:
        start = 4
        end = 5
        while file[end] != 's' and file[end] != 'b' \
            and file[end] != 'd' and file[end] != 'p':
            end += 1
        node_ids += [int(file[start:end])]

    N = max(node_ids) + 1
    os.chdir(dir)
    return N

def Gijkl_speed():
    r = torch.tensor([50,100,100], dtype = dtype)
    nu = 0.278
    mu = 1.0065
    Gijkl1 = torch.zeros((3,3,3,3), dtype = dtype)

    t0 = time.time()
    for i in range(3):
        for j in range(3):
            for k in range(3):
                for l in range(3):
                    Gijkl1[i,j,k,l] = greenDD(r,i,j,k,l,nu,mu)

    t1 = time.time()

    Gijkl3 = torch.tensor(greenDD_mod(r,nu,mu).reshape(3,3,3,3), dtype = dtype)

    t2 = time.time()

    print('time with for loops : ', t1 - t0)
    print('with tensor operation :', t2 - t1)
    print('same result ?\n', torch.max(torch.abs((Gijkl3 - Gijkl1).div(Gijkl1))))

    return 0

# if __name__ == "__main__":
    # P = torch.tensor([[345,342,532],[345,342,532],[345,342,532]], dtype = dtype)
    # r = torch.tensor([100,100,100], dtype = dtype)
    # nu = 0.278
    # mu = 1.0065
    # elastic_S = define_S(nu,mu)
    # a = 3.16
    # t0 = time.time()
    # sigma(P,r,nu,mu,elastic_C)
    # print("Time for sigma computing : ", time.time() - t0, 's')
    #
    # Gijkl_speed()
    # print(num_atoms(2, 3.16))
    # S = define_S(nu,mu)
    # C = define_C(nu,mu)




"""""""""""""""""""""

\\\\\\\\\\\\\\\\\\\\\
 OBSOLETE FUNCTIONS
\\\\\\\\\\\\\\\\\\\\\

"""""""""""""""""""""

def maximum_ind(out_file_name):
    """
    This functions returns the maximum index for a loops
    in a simulation
    Input : out file name '/OUTPUT/out1....'
    Output : maximum index
    """
    # Fetch the data out of the out file
    dir = os.getcwd()
    file = open(dir + out_file_name, 'r')
    data = file.readlines()
    file.close()

    INDEX = []
    for line in data[1:]:
        INDEX += [int(line.split()[1])]

    index = max(INDEX) + 1
    return index


def fetchComponents(DisType):
    """
    This function fetch the components of the dipole tensor of a dislocation Loop
    Not useful anymore...
    Input : dislocation type (111 or 100)
    Output : Dipole tensor components of the dislocation loop
    """
    dir = os.getcwd()
    os.chdir(dir + '/LammpsInput/')

    # We look for the appropriate folder according to what we are looking for
    localdir = os.getcwd()
    directory = os.listdir(localdir)

    # If 111 loop:
    if (DisType == '[0.5 0.5 0.5]'):
        # We want to enter xatoms111_x
        for d in directory:
            if ('atoms111' in d):
                os.chdir(dir + '/LammpsInput/' + d)
                foldername = d

        # Now we want to read the dipole tensor file
        local2dir = os.getcwd()
        directory2 = os.listdir(local2dir)
        for d in directory2:
            if ('dipole_tensor' in d):
                file_dtensor = open(d, 'r')

    # If 100 loop
    elif (DisType == '[1 0 0]'):
        # We want to access xatoms100_x
        for d in directory:
            if ('atoms100' in d):
                os.chdir(dir + '/LammpsInput/' + d)
                foldername = d

        # Now we want to read the dipole tensor file
        local2dir = os.getcwd()
        directory2 = os.listdir(local2dir)
        for d in directory2:
            if ('dipole_tensor' in d):
                file_dtensor = open(d, 'r')

    # Now that we have the dipole tensor file we want to extract the components
    P_inter = file_dtensor.read().split(' ')[0:6]
    P_inter2 = [0]*len(P_inter)

    for k in range(len(P_inter)):
        P_inter2[k] = float(P_inter[k])

    # We then make it on a matrix form for proper introduction to EOM_integrate
    P = np.array([[P_inter2[0], P_inter2[3], P_inter2[5]], \
                  [P_inter2[3], P_inter2[1], P_inter2[4]], \
                  [P_inter2[5], P_inter2[4], P_inter2[2]]])

    # We close the open file
    file_dtensor.close()
    # We suppress the folder for it not to interact with future computation
    os.chdir(dir + '/LammpsInput')
    os.system('rm -R ' + foldername)
    # We return to the working directory
    os.chdir(dir)
    return P
