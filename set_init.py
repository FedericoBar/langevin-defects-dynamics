import os
import numpy as np
import torch
import time

import EOM_struct as EOMs
import linked
import writing
import useful_functions as uf

dtype = torch.double
device = torch.device('cpu')

"""
FIRST : Extract the data from the text file in a way it can be easily processed
"""
def extract_loop_data(name):
    """
    This function extracts, from file name in /insitu_TEM_data, the position, kind, burger vector
    and size of all the defects generated by a given amount of collision cascades.
    Input : name of the file where the DFT data is
    Output : (kind, size, position, burger)
    """
    dir = os.getcwd()
    os.chdir(dir + '/insitu_TEM_data/')

    filename = name
    file = open(filename, 'r')
    insitu_data = file.readlines()
    file.close()

    nbr_lines = len(insitu_data)

    nbr_cascades = int(insitu_data[9].split()[0])

    loops_kind = np.empty((nbr_cascades, ), dtype = list)
    loops_size = np.empty((nbr_cascades, ), dtype = list)
    loops_position = np.empty((nbr_cascades, ), dtype = list)
    loops_burger = np.empty((nbr_cascades, ), dtype = list)

    ind_cascade = []
    for line in range(10, nbr_lines):
        insitu_line = insitu_data[line].split()
        if (insitu_line[2] == "#"):
            ind_cascade += [line]

    for line in range(len(ind_cascade) - 1):
        kind = []
        size = []
        position = []
        burger = []
        for LINE in insitu_data[ind_cascade[line] + 2:ind_cascade[line + 1]]:
            cascade_line = LINE.split()
            kind += [cascade_line[0]]
            size += [float(cascade_line[1])]
            position += [np.array([float(cascade_line[5]), float(cascade_line[6]), float(cascade_line[7])])]
            burger += [np.array([float(cascade_line[2]), float(cascade_line[3]), float(cascade_line[4])])]

        loops_kind[line] = kind
        loops_size[line] = size
        loops_position[line] = position
        loops_burger[line] = burger


    # Let's go back to the initial directory
    os.chdir(dir)
    return loops_kind, loops_size, loops_position, loops_burger


"""
NOW that we have the data formated correctly, let's create the centre position for all the
cascades taking place
"""

def z_distribution(N):
    """
    This function returns a height picked randomly according to the following distribution:
    Normally distributed around 10nm 3sigma = 20nm and 0 below 0nm
    Input : Number of elements we want to pick according to the distribution
    Output : height
    """
    b = np.empty((N,))
    for i in range (N):
        a = np.random.normal(100, 100)
        while (a < 0):
            a = np.random.normal(100, 100)
        b[i] = a

    return b

def cascade_position(N, sample_size):
    """
    This functions returns a randomly generated set of centre position for the collision
    cascades. It will allow us to determine the position of the loops in the sample
    Input : N (number of cascades), and the sample size (could be a tuple if the sample
    is not cubic)
    Output : Position of N cascades in the sample
    """

    position = np.empty((N,3))
    in_plane = np.random.randint(0, sample_size, (N,2))
    height = z_distribution(N)

    for i in range(N):
        position[i] = np.append(in_plane[i], height[i])

    return position


def main(name, sample_size, Ncascades, nu, mu, loops_data):
    """
    This is the main function. It will return the extracted data as a list of defects
    Input : name of the file where the DFT data is, sample size
    which is the in plane size, Ncascades
    number of cascades (during dt) and params
    Output : List of defects object.
    """

    # What are the centre of mass position's of these cascades?
    cas_position = cascade_position(Ncascades, sample_size)
    Z = []

    for pos_cascade in cas_position:
        # Pick a random cascade index:
        i_cascade = np.random.randint(0,10000)
        # How many loop are generated by this cascade
        nbr_loops_in_cascade = len(loops_data[0][i_cascade])
        for i_loop in range(nbr_loops_in_cascade):
            loop_nat = loops_data[0][i_cascade][i_loop]

            # Don't forget that the position in the file is according to the centre
            # of mass of the collision cascade.
            loop_pos = torch.tensor(loops_data[2][i_cascade][i_loop] + pos_cascade)
            loop_bur = torch.tensor(loops_data[3][i_cascade][i_loop])

            # The radius associated with the number of defects
            radius = uf.size_from_num_atoms(loops_data[1][i_cascade][i_loop], loops_bur, EOMs.a)
            loop_rad = torch.tensor(radius)

            if loop_bur.equal(torch.zeros(3, dtype = torch.double)):
                loop_bur = torch.tensor([0.5,0.5,0.5], dtype = dtype, device = device)

            # Convert the size if the defect is a vacancy loop/point defect or a void
            if (loop_nat == "void" or loop_nat == "vac_loop"):
                loop_rad = -loop_rad

            # Compute the dipole tensor :
            loop_dte = uf.dipole_coord_analytical(loop_bur, loop_rad, nu, mu, EOMs.a)
            # Let's create the corresponding loop object (defect)
            start_loop = EOMs.loop_obj(loop_pos, loop_bur, loop_dte, loop_rad)

            Z = Z + [start_loop]
    return Z



#
